Submitted By:            Igor Živković <contact@igor-zivkovic.from.hr>
Date:                    2014-04-23
Initial Package Version: 1.22.1
Upstream Status:         Ignored
Origin:                  Self
Description:             Adds verbose switch to cp, install, mkdir, mv, rm, and
                         rmdir commands

diff -Naur busybox-1.22.1.orig/coreutils/cp.c busybox-1.22.1/coreutils/cp.c
--- busybox-1.22.1.orig/coreutils/cp.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/coreutils/cp.c	2014-05-15 14:35:35.832862010 +0200
@@ -31,6 +31,7 @@
 //usage:     "\n	-f	Overwrite"
 //usage:     "\n	-i	Prompt before overwrite"
 //usage:     "\n	-l,-s	Create (sym)links"
+//usage:     "\n	-v	Verbose"
 
 #include "libbb.h"
 #include "libcoreutils/coreutils.h"
@@ -79,7 +80,6 @@
 		"parents\0"        No_argument "\xff"
 		;
 #endif
-	// -v (--verbose) is ignored
 	flags = getopt32(argv, FILEUTILS_CP_OPTSTR "arPv");
 	/* Options of cp from GNU coreutils 6.10:
 	 * -a, --archive
diff -Naur busybox-1.22.1.orig/coreutils/install.c busybox-1.22.1/coreutils/install.c
--- busybox-1.22.1.orig/coreutils/install.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/coreutils/install.c	2014-05-15 14:35:40.144678662 +0200
@@ -12,6 +12,7 @@
 //usage:#define install_full_usage "\n\n"
 //usage:       "Copy files and set attributes\n"
 //usage:     "\n	-c	Just copy (default)"
+//usage:     "\n	-v	Verbose"
 //usage:     "\n	-d	Create directories"
 //usage:     "\n	-D	Create leading target directories"
 //usage:     "\n	-s	Strip symbol table"
@@ -28,6 +29,7 @@
 
 #if ENABLE_FEATURE_INSTALL_LONG_OPTIONS
 static const char install_longopts[] ALIGN1 =
+	"verbose\0"             No_argument       "v"
 	"directory\0"           No_argument       "d"
 	"preserve-timestamps\0" No_argument       "p"
 	"strip\0"               No_argument       "s"
@@ -89,6 +91,7 @@
 	const char *gid_str;
 	const char *uid_str;
 	const char *mode_str;
+	int mkdir_flags = FILEUTILS_RECUR;
 	int copy_flags = FILEUTILS_DEREFERENCE | FILEUTILS_FORCE;
 	int opts;
 	int min_args = 1;
@@ -120,7 +123,6 @@
 #endif
 	opt_complementary = "s--d:d--s" IF_FEATURE_INSTALL_LONG_OPTIONS(IF_SELINUX(":Z--\xff:\xff--Z"));
 	/* -c exists for backwards compatibility, it's needed */
-	/* -v is ignored ("print name of each created directory") */
 	/* -b is ignored ("make a backup of each existing destination file") */
 	opts = getopt32(argv, "cvb" "Ddpsg:m:o:" IF_SELINUX("Z:"),
 			&gid_str, &mode_str, &uid_str IF_SELINUX(, &scontext));
@@ -141,6 +143,11 @@
 	}
 #endif
 
+	if (opts & OPT_v) {
+		mkdir_flags |= FILEUTILS_VERBOSE;
+		copy_flags |= FILEUTILS_VERBOSE;
+	}
+
 	/* preserve access and modification time, this is GNU behaviour,
 	 * BSD only preserves modification time */
 	if (opts & OPT_PRESERVE_TIME) {
@@ -171,14 +178,14 @@
 			/* GNU coreutils 6.9 does not set uid:gid
 			 * on intermediate created directories
 			 * (only on last one) */
-			if (bb_make_directory(dest, 0755, FILEUTILS_RECUR)) {
+			if (bb_make_directory(dest, 0755, mkdir_flags)) {
 				ret = EXIT_FAILURE;
 				goto next;
 			}
 		} else {
 			if (opts & OPT_MKDIR_LEADING) {
 				char *ddir = xstrdup(dest);
-				bb_make_directory(dirname(ddir), 0755, FILEUTILS_RECUR);
+				bb_make_directory(dirname(ddir), 0755, mkdir_flags);
 				/* errors are not checked. copy_file
 				 * will fail if dir is not created. */
 				free(ddir);
diff -Naur busybox-1.22.1.orig/coreutils/mkdir.c busybox-1.22.1/coreutils/mkdir.c
--- busybox-1.22.1.orig/coreutils/mkdir.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/coreutils/mkdir.c	2014-05-15 14:35:35.834861926 +0200
@@ -25,6 +25,7 @@
 //usage:       "Create DIRECTORY\n"
 //usage:     "\n	-m MODE	Mode"
 //usage:     "\n	-p	No error if exists; make parent directories as needed"
+//usage:     "\n	-v	Verbose"
 //usage:	IF_SELINUX(
 //usage:     "\n	-Z	Set security context"
 //usage:	)
@@ -45,10 +46,10 @@
 static const char mkdir_longopts[] ALIGN1 =
 	"mode\0"    Required_argument "m"
 	"parents\0" No_argument       "p"
+	"verbose\0" No_argument       "v"
 #if ENABLE_SELINUX
 	"context\0" Required_argument "Z"
 #endif
-	"verbose\0" No_argument       "v"
 	;
 #endif
 
@@ -67,7 +68,7 @@
 #if ENABLE_FEATURE_MKDIR_LONG_OPTIONS
 	applet_long_options = mkdir_longopts;
 #endif
-	opt = getopt32(argv, "m:p" IF_SELINUX("Z:") "v", &smode IF_SELINUX(,&scontext));
+	opt = getopt32(argv, "m:pv" IF_SELINUX("Z:"), &smode IF_SELINUX(,&scontext));
 	if (opt & 1) {
 		mode_t mmode = 0777;
 		if (!bb_parse_mode(smode, &mmode)) {
@@ -77,8 +78,10 @@
 	}
 	if (opt & 2)
 		flags |= FILEUTILS_RECUR;
+	if (opt & 4)
+		flags |= FILEUTILS_VERBOSE;
 #if ENABLE_SELINUX
-	if (opt & 4) {
+	if (opt & 8) {
 		selinux_or_die();
 		setfscreatecon_or_die(scontext);
 	}
diff -Naur busybox-1.22.1.orig/coreutils/mv.c busybox-1.22.1/coreutils/mv.c
--- busybox-1.22.1.orig/coreutils/mv.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/coreutils/mv.c	2014-05-15 14:35:35.837861798 +0200
@@ -17,13 +17,14 @@
 #include "libcoreutils/coreutils.h"
 
 //usage:#define mv_trivial_usage
-//usage:       "[-fin] SOURCE DEST\n"
-//usage:       "or: mv [-fin] SOURCE... DIRECTORY"
+//usage:       "[-finv] SOURCE DEST\n"
+//usage:       "or: mv [-finv] SOURCE... DIRECTORY"
 //usage:#define mv_full_usage "\n\n"
 //usage:       "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY\n"
 //usage:     "\n	-f	Don't prompt before overwriting"
 //usage:     "\n	-i	Interactive, prompt before overwrite"
 //usage:     "\n	-n	Don't overwrite an existing file"
+//usage:     "\n	-v	Verbose"
 //usage:
 //usage:#define mv_example_usage
 //usage:       "$ mv /tmp/foo /bin/bar\n"
@@ -40,6 +41,7 @@
 #define OPT_FORCE       (1 << 0)
 #define OPT_INTERACTIVE (1 << 1)
 #define OPT_NOCLOBBER   (1 << 2)
+#define OPT_VERBOSE     (1 << 3)
 
 int mv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int mv_main(int argc, char **argv)
@@ -58,7 +60,6 @@
 	/* Need at least two arguments.
 	 * If more than one of -f, -i, -n is specified , only the final one
 	 * takes effect (it unsets previous options).
-	 * -v is accepted but ignored.
 	 */
 	opt_complementary = "-2:f-in:i-fn:n-fi";
 	flags = getopt32(argv, "finv");
@@ -148,6 +149,9 @@
 			status = 1;
 		}
  RET_0:
+		if (flags & OPT_VERBOSE) {
+			printf("`%s' -> `%s'\n", *argv, dest);
+		}
 		if (dest != last) {
 			free((void *) dest);
 		}
diff -Naur busybox-1.22.1.orig/coreutils/rm.c busybox-1.22.1/coreutils/rm.c
--- busybox-1.22.1.orig/coreutils/rm.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/coreutils/rm.c	2014-05-15 14:35:35.838861756 +0200
@@ -22,6 +22,7 @@
 //usage:     "\n	-i	Always prompt before removing"
 //usage:     "\n	-f	Never prompt"
 //usage:     "\n	-R,-r	Recurse"
+//usage:     "\n	-v	Verbose"
 //usage:
 //usage:#define rm_example_usage
 //usage:       "$ rm -rf /tmp/foo\n"
@@ -38,7 +39,6 @@
 	unsigned opt;
 
 	opt_complementary = "f-i:i-f";
-	/* -v (verbose) is ignored */
 	opt = getopt32(argv, "fiRrv");
 	argv += optind;
 	if (opt & 1)
@@ -47,6 +47,8 @@
 		flags |= FILEUTILS_INTERACTIVE;
 	if (opt & (8|4))
 		flags |= FILEUTILS_RECUR;
+	if (opt & 16)
+		flags |= FILEUTILS_VERBOSE;
 
 	if (*argv != NULL) {
 		do {
diff -Naur busybox-1.22.1.orig/coreutils/rmdir.c busybox-1.22.1/coreutils/rmdir.c
--- busybox-1.22.1.orig/coreutils/rmdir.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/coreutils/rmdir.c	2014-05-15 14:35:35.840861671 +0200
@@ -16,10 +16,12 @@
 //usage:       "Remove DIRECTORY if it is empty\n"
 //usage:	IF_FEATURE_RMDIR_LONG_OPTIONS(
 //usage:     "\n	-p|--parents	Include parents"
+//usage:     "\n	-v|--verbose	Verbose"
 //usage:     "\n	--ignore-fail-on-non-empty"
 //usage:	)
 //usage:	IF_NOT_FEATURE_RMDIR_LONG_OPTIONS(
 //usage:     "\n	-p	Include parents"
+//usage:     "\n	-v	Verbose"
 //usage:	)
 //usage:
 //usage:#define rmdir_example_usage
@@ -31,7 +33,7 @@
 
 
 #define PARENTS          (1 << 0)
-//efine VERBOSE          (1 << 1) //accepted but ignored
+#define VERBOSE          (1 << 1)
 #define IGNORE_NON_EMPTY (1 << 2)
 
 int rmdir_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -62,6 +64,10 @@
 		path = *argv;
 
 		while (1) {
+			if (flags & VERBOSE) {
+				printf("rmdir: removing directory, `%s'\n", path);
+			}
+
 			if (rmdir(path) < 0) {
 #if ENABLE_FEATURE_RMDIR_LONG_OPTIONS
 				if ((flags & IGNORE_NON_EMPTY) && errno == ENOTEMPTY)
diff -Naur busybox-1.22.1.orig/include/libbb.h busybox-1.22.1/include/libbb.h
--- busybox-1.22.1.orig/include/libbb.h	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/include/libbb.h	2014-05-15 14:35:35.847861373 +0200
@@ -334,6 +334,7 @@
 	FILEUTILS_SET_SECURITY_CONTEXT = 1 << 10,
 #endif
 	FILEUTILS_IGNORE_CHMOD_ERR = 1 << 11,
+	FILEUTILS_VERBOSE         = 1 << 12, /* -v */
 };
 #define FILEUTILS_CP_OPTSTR "pdRfilsLH" IF_SELINUX("c")
 extern int remove_file(const char *path, int flags) FAST_FUNC;
diff -Naur busybox-1.22.1.orig/libbb/copy_file.c busybox-1.22.1/libbb/copy_file.c
--- busybox-1.22.1.orig/libbb/copy_file.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/libbb/copy_file.c	2014-05-15 14:35:35.855861033 +0200
@@ -389,5 +389,9 @@
 			bb_perror_msg("can't preserve %s of '%s'", "permissions", dest);
 	}
 
+	if (flags & FILEUTILS_VERBOSE) {
+		printf("`%s' -> `%s'\n", source, dest);
+	}
+
 	return retval;
 }
diff -Naur busybox-1.22.1.orig/libbb/make_directory.c busybox-1.22.1/libbb/make_directory.c
--- busybox-1.22.1.orig/libbb/make_directory.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/libbb/make_directory.c	2014-05-15 14:35:53.735100876 +0200
@@ -99,6 +99,10 @@
 			if (!c) {
 				goto ret0;
 			}
+		} else {
+			if (flags & FILEUTILS_VERBOSE) {
+			    printf("created directory: `%s'\n", path);
+			}
 		}
 
 		if (!c) {
diff -Naur busybox-1.22.1.orig/libbb/remove_file.c busybox-1.22.1/libbb/remove_file.c
--- busybox-1.22.1.orig/libbb/remove_file.c	2014-01-09 19:15:44.000000000 +0100
+++ busybox-1.22.1/libbb/remove_file.c	2014-05-15 14:35:35.860860821 +0200
@@ -78,6 +78,10 @@
 			return -1;
 		}
 
+		if (flags & FILEUTILS_VERBOSE) {
+			printf("removed directory: `%s'\n", path);
+		}
+
 		return status;
 	}
 
@@ -98,5 +102,9 @@
 		return -1;
 	}
 
+	if (flags & FILEUTILS_VERBOSE) {
+		printf("removed `%s'\n", path);
+	}
+
 	return 0;
 }
